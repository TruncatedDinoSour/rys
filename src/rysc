#!/usr/bin/env python3
"""rys"""

import os
import sys
import warnings
from dataclasses import dataclass
from enum import Enum, auto
from typing import Any, Generator, Optional

import numpy as np

warnings.filterwarnings("error", category=Warning)

EXIT_OK: int = 0
EXIT_ERR: int = 1
RYS_ARGS: set[str] = set()
MAX_64 = 2**64

__version__ = "0.2"
__author__ = "Ari Archer <ari.web.xyz@gmail.com>"


class TokenType(Enum):
    PUSH_INT = auto()
    PUSH_STR = auto()
    INSTRUCTION = auto()
    DROP = auto()
    ASSEMBLY = auto()
    CHARZ = auto()
    OPERATOR = auto()
    STACKSZ = auto()
    CPY = auto()
    NOP = auto()
    CLEAR = auto()
    PROCCESSABLE = auto()


class ProceesableToken(Enum):
    PROC_INCLUDE = auto()


class OperatorType(Enum):
    PLUS = auto()
    MINUS = auto()
    MULTIPLY = auto()
    DIVIDE = auto()
    MODULO = auto()
    POWER = auto()


class AsmFeatures(Enum):
    EXIT = auto()
    WRITEFD = auto()
    WRITEFD_INT = auto()


class InstructionType(Enum):
    INSTRUCTION_EXIT = auto()
    INSTRUCTION_WRITEFD = auto()


class RysType(Enum):
    STR = auto()
    INT = auto()


@dataclass
class Token:
    t_type: TokenType
    t_pos: tuple[int, int, str]  # line, column, file
    t_value: Any


ASM_FEATURES: dict[AsmFeatures, list[str]] = {
    AsmFeatures.EXIT: ["_std_rys_exit:", "    mov rax, 60", "    syscall", "    ret"],
    AsmFeatures.WRITEFD: [
        "_std_rys_writefd:",
        "    mov rax, 1",
        "    syscall",
        "    ret",
    ],
    AsmFeatures.WRITEFD_INT: [
        "_std_rys_writefd_int:",
        "    mov r9, -3689348814741910323",
        "    sub rsp, 40",
        "    lea rcx, [rsp+30]",
        ".L2:",
        "    mov rax, rdi",
        "    lea r8, [rsp+32]",
        "    mul r9",
        "    mov rax, rdi",
        "    sub r8, rcx",
        "    shr rdx, 3",
        "    lea rsi, [rdx+rdx*4]",
        "    add rsi, rsi",
        "    sub rax, rsi",
        "    add eax, 48",
        "    mov BYTE [rcx], al",
        "    mov rax, rdi",
        "    mov rdi, rdx",
        "    mov rdx, rcx",
        "    sub rcx, 1",
        "    cmp rax, 9",
        "    ja .L2",
        "    lea rax, [rsp+32]",
        "    sub rdx, rax",
        "    xor eax, eax",
        "    lea rsi, [rsp+32+rdx]",
        "    mov rdx, r8",
        "    mov rax, 1",
        "    syscall",
        "    add rsp, 40",
        "    ret",
    ],
}


def msg(msg: str, header: str = "ERROR") -> int:
    """Print message and return error exit code"""

    if "quiet" not in RYS_ARGS:
        sys.stderr.write(f" ** {header}{': ' if msg[0] != ':' else ''}{msg}\n")

    return EXIT_ERR


def tk_die(message: str, token: Token) -> None:
    sys.exit(
        msg(f":{token.t_pos[2]}:{token.t_pos[0] or 1}:{token.t_pos[1] or 1}: {message}")
    )


def vprint(message: str) -> None:
    if "verbose" not in RYS_ARGS:
        return

    msg(message, "DEBUG")


assert len(RysType) == 2, "Unhandled types in type-to-string"


def type_to_str(r_type: RysType) -> str:
    type_name = f"Unknown ({r_type})"

    if r_type == RysType.INT:
        type_name = "integer"
    elif r_type == RysType.STR:
        type_name = "string"

    return type_name


assert len(TokenType) == 12, "Unhandled token types in AST generation"
assert len(InstructionType) == 2, "Unhandled instructions in AST generation"
assert len(RysType) == 2, "Unhandled types in AST generation"
assert len(OperatorType) == 6, "Unhandled operator types in AST generation"
assert len(ProceesableToken) == 1, "Unhandled processable token types in AST generation"


def rys_to_ast(file_path: str) -> Generator[Token, None, None]:
    msg(f"Generating AST for {file_path!r}...", "INFO")

    config: dict[str, Any] = {}
    token_ctx: set[str] = set()
    tmp_stack: list[Any] = []

    def new_token(token_type: TokenType, value: Any) -> Token:
        vprint(f"New token with type {token_type!r} and value of {value!r}")

        return Token(
            token_type,
            (config.get("line") or 1, config.get("column") or 1, file_path),
            value,
        )

    def die(message: str) -> None:
        sys.exit(
            msg(
                f":{file_path}:{config.get('line') or 1}:{config.get('column') or 1}: {message}"
            )
        )

    with open(file_path, "r") as rys_code:
        for lidx, line in enumerate(rys_code, 1):
            if "in.literal" in token_ctx:
                die(
                    f'No closing double quote (") to close {type_to_str(RysType.STR)}',
                )

            config["line"] = lidx

            for cidx, token in enumerate(line.split(), 1):
                config["column"] = cidx

                # String parsing sux
                # TODO: better parsing like wtf does this even fucking
                #       like I mean it works, but I have no idea how to
                #       maintain it, please help :')
                #       btw "\\" does not work

                if "in.literal" in token_ctx:
                    if not token.endswith('"') or token.endswith('\\"'):
                        tmp_stack.append(token)
                        continue
                elif token == '"' and "in.literal" not in token_ctx:
                    token_ctx.add("in.literal")
                    continue

                if (
                    token.startswith('"')
                    and token.endswith('"')
                    and not token.endswith('\\"')
                    and "in.literal" not in token_ctx
                ):
                    yield new_token(TokenType.PUSH_STR, token[1:-1])
                    continue
                elif token.endswith('"') and not token.endswith('\\"'):
                    tmp_stack.append(token.removesuffix('"'))

                    full_str: str = " ".join(tmp_stack)

                    yield new_token(TokenType.PUSH_STR, full_str)

                    tmp_stack = []
                    token_ctx.remove("in.literal")
                    continue
                elif token.startswith('"'):
                    tmp_stack.append(token.removeprefix('"'))
                    token_ctx.add("in.literal")
                    continue

                if token.startswith("--"):
                    # Ignore comments and everything after in the same line
                    break

                if token.isnumeric():
                    try:
                        yield new_token(TokenType.PUSH_INT, int(token))
                    except ValueError:
                        die(
                            f"Failed to convert {token!r} to {type_to_str(RysType.INT)}"
                        )
                else:
                    if token == "exit":
                        yield new_token(
                            TokenType.INSTRUCTION, InstructionType.INSTRUCTION_EXIT
                        )
                    elif token == "writefd":
                        yield new_token(
                            TokenType.INSTRUCTION, InstructionType.INSTRUCTION_WRITEFD
                        )
                    elif token == "cpy":
                        yield new_token(TokenType.CPY, None)
                    elif token == "drop":
                        yield new_token(TokenType.DROP, None)
                    elif token == "assembly":
                        yield new_token(TokenType.ASSEMBLY, None)
                    elif token == "charz":
                        yield new_token(TokenType.CHARZ, None)
                    elif token == "+":
                        yield new_token(TokenType.OPERATOR, OperatorType.PLUS)
                    elif token == "-":
                        yield new_token(TokenType.OPERATOR, OperatorType.MINUS)
                    elif token == "*":
                        yield new_token(TokenType.OPERATOR, OperatorType.MULTIPLY)
                    elif token == "/":
                        yield new_token(TokenType.OPERATOR, OperatorType.DIVIDE)
                    elif token == "%":
                        yield new_token(TokenType.OPERATOR, OperatorType.MODULO)
                    elif token == "**":
                        yield new_token(TokenType.OPERATOR, OperatorType.POWER)
                    elif token == "stacksz":
                        yield new_token(TokenType.STACKSZ, None)
                    elif token == "nop":
                        yield new_token(TokenType.NOP, None)
                    elif token == "clear":
                        yield new_token(TokenType.CLEAR, None)
                    elif token == "include":
                        yield new_token(
                            TokenType.PROCCESSABLE, ProceesableToken.PROC_INCLUDE
                        )
                    else:
                        die(f"Unknown token: {token!r}")

            if "in.literal" in token_ctx:
                die(f'No closing double quote (") to close {type_to_str(RysType.STR)}')


assert (
    len(TokenType) == 12
), "Unhandled token types in nasm x86_64 linux assembly generation"
assert len(InstructionType) == 2, "Unhandled instructions in assembly generation"
assert len(RysType) == 2, "Unhandled types in assembly generation"
assert (
    len(AsmFeatures) == 3
), "Unhandled asm features in generate_x86_64_nasm_assembly_linux()"
assert len(OperatorType) == 6, "Unhandled operator types in assembly generation"
assert (
    len(ProceesableToken) == 1
), "Unhandled processable token types in nasm x86_64 linux assembly generation"


def generate_x86_64_nasm_assembly_linux(
    ast: Generator[Token, None, None],
    full: bool = True,
    start_iname: int = 0,
    stack: Optional[list[tuple[Any, RysType]]] = None,
    features: Optional[set[AsmFeatures]] = None,
    do_msg: bool = True,
) -> Generator[tuple[str, int], None, None]:
    """
    API (index 1 of return)
    -----------------------
    0 -- assembly
    1 -- data
    """

    if do_msg:
        msg("Generating nasm x86_64 linux assembly from AST...", "INFO")

    asm_stack: list[tuple[Any, RysType]] = stack or []
    asm_data: list[Any] = []
    asm_features: set[AsmFeatures] = features or set()
    start_lb: list[str] = []

    tmp_stack: list[Any] = []

    if full:
        vprint("Generating nasm x86_64 64-bit initial header")

        yield "BITS 64", 0
        yield "segment .text", 0

    for token in ast:
        iname: str = f"_{start_iname}_{token.t_pos[0]}_{token.t_pos[1]}"
        vprint(f"Parsing token {iname!r}")

        if token.t_type == TokenType.PUSH_INT:
            vprint(
                f"Checking if {type_to_str(RysType.INT)} {token.t_value!r} fits into 64 bits"
            )

            if token.t_value > MAX_64:
                tk_die(
                    f"{type_to_str(RysType.INT)} {token.t_value!r} does not fit into 64 bits",
                    token,
                )

            asm_stack.append((token.t_value, RysType.INT))
        elif token.t_type == TokenType.PUSH_STR:
            vprint(f"Pushing {type_to_str(RysType.STR)} {token.t_value!r} onto stack")

            asm_stack.append(
                (
                    token.t_value.encode("raw_unicode_escape", errors="ignore").decode(
                        "unicode_escape", errors="ignore"
                    ),
                    RysType.STR,
                )
            )
        elif token.t_type == TokenType.DROP:
            drop_ammount = asm_stack.pop()[0]
            vprint(f"Droppping {drop_ammount} of elements from the stack")

            for _ in range(drop_ammount):
                asm_stack.pop()
        elif token.t_type == TokenType.ASSEMBLY:
            assembly_ammount: int = asm_stack.pop()[0]
            vprint(f"Injecting extra {assembly_ammount} lines of assembly code")

            for _ in range(assembly_ammount):
                start_lb.append(asm_stack.pop()[0])
        elif token.t_type == TokenType.CHARZ:
            charz_ammount = asm_stack.pop()[0]
            vprint(
                f"Converting {charz_ammount} of charcodes into {type_to_str(RysType.STR)}"
            )

            for _ in range(charz_ammount):
                tmp_stack.append(chr(asm_stack.pop()[0]))

            asm_stack.append(("".join(tmp_stack), RysType.STR))
            tmp_stack = []
        elif token.t_type == TokenType.CPY:
            cpy_ammount = asm_stack.pop()[0]
            vprint(f"Copying {cpy_ammount} items from the stack")

            for idx in range(cpy_ammount):
                tmp_stack.append(asm_stack[-(idx + 1)])

            asm_stack += tmp_stack[::-1]
            tmp_stack = []
        elif token.t_type == TokenType.OPERATOR:
            if token.t_value == OperatorType.PLUS:
                value1 = asm_stack.pop()[0]
                value2 = asm_stack.pop()[0]

                vprint(f"Summing {value1} and {value2}")

                final = value1 + value2

                if final > MAX_64:
                    tk_die(
                        f"{type_to_str(RysType.INT)} {final!r} does not fit into 64 bits",
                        token,
                    )

                asm_stack.append((final, RysType.INT))
            elif token.t_value == OperatorType.MINUS:
                value1 = asm_stack.pop()[0]
                value2 = asm_stack.pop()[0]

                vprint(f"Subtracting {value2} from {value1}")

                final = value1 - value2

                if final > MAX_64:
                    tk_die(
                        f"{type_to_str(RysType.INT)} {final!r} does not fit into 64 bits",
                        token,
                    )

                asm_stack.append((final, RysType.INT))
            elif token.t_value == OperatorType.MULTIPLY:
                value1 = asm_stack.pop()[0]
                value2 = asm_stack.pop()[0]

                vprint(f"Multipying {value1} {value2} times")

                final = np.multiply(value1, value2)

                if final > MAX_64:
                    tk_die(
                        f"{type_to_str(RysType.INT)} {final!r} does not fit into 64 bits",
                        token,
                    )

                asm_stack.append((final, RysType.INT))
            elif token.t_value == OperatorType.DIVIDE:
                value1 = asm_stack.pop()[0]
                value2 = asm_stack.pop()[0]

                vprint(f"Dividing {value1} into {value2} parts")

                final = np.floor_divide(value1, value2)

                if final > MAX_64:
                    tk_die(
                        f"{type_to_str(RysType.INT)} {final!r} does not fit into 64 bits",
                        token,
                    )

                asm_stack.append((final, RysType.INT))
            elif token.t_value == OperatorType.MODULO:
                value1 = asm_stack.pop()[0]
                value2 = asm_stack.pop()[0]

                vprint(f"Calculating {value1} modulo of {value2}")

                final = np.mod(value1, value2)

                if final > MAX_64:
                    tk_die(
                        f"{type_to_str(RysType.INT)} {final!r} does not fit into 64 bits",
                        token,
                    )

                asm_stack.append((final, RysType.INT))
            elif token.t_value == OperatorType.POWER:
                value1 = asm_stack.pop()[0]
                value2 = asm_stack.pop()[0]

                vprint(f"Raising {value1} to the power of {value2}")

                final = np.power(value1, value2)

                if final > MAX_64:
                    tk_die(
                        f"{type_to_str(RysType.INT)} {final!r} does not fit into 64 bits",
                        token,
                    )

                asm_stack.append((final, RysType.INT))
            else:
                tk_die(f"Unknown operator: {token.t_value}", token)
        elif token.t_type == TokenType.STACKSZ:
            vprint("Pushing stack size onto the stack")
            asm_stack.append((len(asm_stack), RysType.INT))
        elif token.t_type == TokenType.NOP:
            vprint("Adding a `nop` instruction to _start label")
            start_lb.append("    nop")
        elif token.t_type == TokenType.CLEAR:
            vprint("Clearing the stack")
            asm_stack = []
        elif token.t_type == TokenType.PROCCESSABLE:
            vprint(
                "This is most likely a compiler bug, processable token detected in generate_x86_64_nasm_assembly_linux()"
            )
            tk_die(f"This token should be handled in preprocessing: {token}", token)
        elif token.t_type == TokenType.INSTRUCTION:
            vprint("Generating assembly for instruction")

            if token.t_value == InstructionType.INSTRUCTION_EXIT:
                vprint("Adding a call to _std_rys_exit in _start label")
                start_lb += [f"mov rdi, {asm_stack.pop()[0]}", "call _std_rys_exit"]

                vprint("Adding EXIT feature to assembly features")
                asm_features.add(AsmFeatures.EXIT)
            elif token.t_value == InstructionType.INSTRUCTION_WRITEFD:
                writefd_fd, _, writefd_string, writefd_string_type = (
                    *asm_stack.pop(),
                    *asm_stack.pop(),
                )

                if writefd_string_type == RysType.STR:
                    vprint("Adding call to _std_rys_writefd to start label")

                    start_lb += [
                        f"    mov rdi, {writefd_fd}",
                        f"    mov rsi, str{iname}",
                        f"    mov rdx, str_len{iname}",
                        r"    call _std_rys_writefd",
                    ]

                    rys_str: str = ",".join(
                        map(lambda char: str(ord(char)), writefd_string)
                    )

                    asm_data += [
                        f"str{iname}: db {rys_str if rys_str else 0}",
                        f"str_len{iname}: equ $-str{iname}",
                    ]

                    vprint("Adding WRITEFD feature to assembly features")
                    asm_features.add(AsmFeatures.WRITEFD)
                elif writefd_string_type == RysType.INT:
                    vprint("Adding call to _std_rys_writefd_int to start label")

                    start_lb += [
                        f"    mov rdi, {writefd_fd}",
                        f"    mov edi, {writefd_string}",
                        r"    call _std_rys_writefd_int",
                    ]

                    vprint("Adding WRITEFD_INT feature to assembly features")
                    asm_features.add(AsmFeatures.WRITEFD_INT)

                vprint("Pushing the string length onto the stack")
                asm_stack.append((len(str(writefd_string)), RysType.INT))
            else:
                tk_die(f"Unknown instruction: {token.t_value}", token)
        else:
            tk_die(f"Unknown token: {token.t_type}", token)

    vprint("Checking for unhandled stack items...")
    if asm_stack:
        msg(f"{len(asm_stack)} item(s) left on the stack:")

        for val, typ in asm_stack:
            sys.stderr.write(f"  *  {val!r}{type_to_str(typ):>10s}\n")

        sys.exit(EXIT_ERR)

    vprint("Generating features...")

    for feature in asm_features:
        for line in ASM_FEATURES[feature]:
            yield line, 0

    vprint("Generating _start")

    if not start_lb:
        msg("No actual code found")
        sys.exit(EXIT_ERR)

    if full:
        vprint("Generating _start label header")
        yield "global _start", 0
        yield "_start:", 0

    for line in start_lb:
        yield line, 0

    vprint("generating .data")

    if full and asm_data:
        yield "segment .data", 1

    for data in asm_data:
        yield data, 1


def usage() -> int:
    help_text = [
        f" Usage: {{ENV}}={{VAL}}... {os.path.basename(sys.argv[0])} <file | -help> -flag(s)",
        "",
        " FLAGS",
        f"    -help                       -- [{'on' if '-help' in sys.argv else 'off'}] print help",
        f"    -debug                      -- [{'on' if '-debug' in sys.argv else 'off'}] use debug build flags",
        f"    -release                    -- [{'on' if '-release' in sys.argv else 'off'}] use release/production build flags",
        f"    -linux-elf64-x86_64-nasm    -- [{'on' if '-linux-elf64-x86_64-nasm' in sys.argv else 'off'}] generate linux elf64 x86_64 binary and assembly",
        f"    -run                        -- [{'on' if '-run' in sys.argv else 'off'}] run binary after compilation",
        f"    --                          -- [{'on' if '--' in sys.argv[1:] else 'off'}] treat next argument as filename",
        f"    -o <filename>               -- [{'on' if '-o' in sys.argv[1:] else 'off'}] output binary",
        f"    -strip                      -- [{'on' if '-strip' in sys.argv else 'off'}] strip binary after compiling",
        f"    -quiet                      -- [{'on' if '-quiet' in sys.argv else 'off'}] run quietly",
        f"    -verbose                    -- [{'on' if '-quiet' in sys.argv else 'off'}] print debug/verbose information",
        f"    -typecheck                  -- [{'on' if '-typecheck' in sys.argv else 'off'}] only typecheck, don't compile",
        f"    -no-typecheck               -- [{'on' if '-no-typecheck' in sys.argv else 'off'}] never typecheck",
        "",
        " ENV",
        "    RYS_LD_FLAGS                -- all linker flags",
        "    RYS_USER_LD_FLAGS           -- extra linker flags to add on top of LD flags",
        "    RYS_ASM_FLAGS               -- all assembly flags",
        "    RYS_USER_ASM_FLAGS          -- extra assembly flags to add on top of ASM flags",
        "    RYS_OFLAGS                  -- flags to pass to output binary if -run is passed",
    ]

    print("\n".join(help_text), file=sys.stderr)
    return EXIT_ERR


def parse_args() -> tuple[str, str]:
    """Returns the filename and output binary name"""

    if sys.argv[1] == "-help":
        usage()
        sys.exit(EXIT_OK)

    ctx: set = set()
    filename: str = sys.argv[1]
    output: str = ""

    for arg in sys.argv[1:]:
        if "literal" in ctx:
            filename = arg
            ctx.remove("literal")
            continue
        elif "output" in ctx:
            output = arg
            ctx.remove("output")
            continue

        if arg == "-help":
            usage()
            sys.exit()
        elif arg == "-debug":
            RYS_ARGS.add("debug_flags")
        elif arg == "-release":
            RYS_ARGS.add("release_flags")
        elif arg == "-linux-elf64-x86_64-nasm":
            RYS_ARGS.add("format_linux_elf64_x86_64_nasm")
        elif arg == "-run":
            RYS_ARGS.add("run")
        elif arg == "--":
            ctx.add("literal")
        elif arg == "-o":
            ctx.add("output")
        elif arg == "-strip":
            RYS_ARGS.add("strip")
        elif arg == "-quiet":
            RYS_ARGS.add("quiet")
        elif arg == "-verbose":
            RYS_ARGS.add("verbose")
        elif arg == "-typecheck":
            RYS_ARGS.add("typing")
        elif arg == "-no-typecheck":
            RYS_ARGS.add("no-typing")
        elif os.path.exists(arg):
            continue
        else:
            sys.exit(msg(f"Unknown argument: {arg!r}"))

    vprint("Finished parsing arguments")
    return (filename, output or os.path.splitext(os.path.basename(filename))[0])


assert len(TokenType) == 12, "Unhandled token types in type checking"
assert len(InstructionType) == 2, "Unhandled instructions in type checking"
assert len(RysType) == 2, "Unhandled types in type checking"
assert len(OperatorType) == 6, "Unhandled operator types in type checking"
assert len(ProceesableToken) == 1, "Unhandled processable token types in type checking"


def type_check_ast(
    ast: Generator[Token, None, None],
    do_msg: bool = True,
    tp_stack: Optional[list[tuple[RysType, Any]]] = None,
) -> Generator[Token, None, None]:
    if "no-typing" in RYS_ARGS:
        vprint("Not type-checking AST")

        for token in ast:
            yield token

        return

    vprint("Type checking AST")

    if do_msg:
        msg("Type checking program...", "INFO")

    stack: list[tuple[RysType, Any]] = tp_stack or []
    tmp_stack: list[Any] = []

    for token in ast:
        if token.t_type == TokenType.PUSH_INT:
            vprint(f"Type checking stack: push {type_to_str(RysType.INT)}")
            stack.append((RysType.INT, token.t_value))
        elif token.t_type == TokenType.PUSH_STR:
            vprint(f"Type checking stack: push {type_to_str(RysType.STR)}")
            stack.append((RysType.STR, token.t_value))
        elif token.t_type == TokenType.INSTRUCTION:
            vprint("Found instruction")

            if token.t_value == InstructionType.INSTRUCTION_EXIT:
                vprint("Type checking exit instruction")

                if len(stack) < 1:
                    tk_die("Exit code not supplied", token)

                exit_code_type, _ = stack.pop()
                if exit_code_type != RysType.INT:
                    tk_die(
                        f"Exit expected {type_to_str(RysType.INT)} on the stack as exit code, but got {type_to_str(exit_code_type)}",
                        token,
                    )
            elif token.t_value == InstructionType.INSTRUCTION_WRITEFD:
                vprint("Type checking writefd instruction")

                if len(stack) < 2:
                    tk_die("Not enough arguments for writefd", token)

                vprint("Checking file descriptor type")
                fd_type = stack.pop()[0]

                if fd_type != RysType.INT:
                    tk_die(
                        f"WriteFD expected a {type_to_str(RysType.INT)} {type_to_str(RysType.INT)} the stack as the file descriptor, but got {type_to_str(fd_type)}",
                        token,
                    )

                vprint("Checking string compatibility")
                string_type, string = stack.pop()

                if string_type not in (RysType.STR, RysType.INT):
                    tk_die(
                        f"writefd expected one of {', '.join(type_to_str(typ) for typ in (RysType.INT, RysType.STR))} on the stack as the content, but got {type_to_str(string_type)}",
                        token,
                    )

                stack.append((RysType.INT, len(str(string))))
            else:
                tk_die(
                    f"Unknown instruction: {token.t_value}",
                    token,
                )
        elif token.t_type == TokenType.DROP:
            vprint("Type checking drop")

            if len(stack) < 2:
                tk_die("Not enough arguments for drop", token)

            vprint("Checking drop ammount type")
            drop_ammount_type, drop_ammount = stack.pop()

            if drop_ammount_type != RysType.INT:
                tk_die(
                    f"Drop expected a {type_to_str(RysType.INT)} on the stack as the ammount of items to drop, but got {type_to_str(drop_ammount_type)}",
                    token,
                )

            vprint("Checking stack size")
            if len(stack) < drop_ammount:
                tk_die(
                    f"Drop: {drop_ammount} is bigger than the elements on the stack: {len(stack)}",
                    token,
                )

            vprint(f"Dropping {drop_ammount} elements from the type checking stack")
            for _ in range(drop_ammount):
                stack.pop()
        elif token.t_type == TokenType.ASSEMBLY:
            vprint("Type checking assembly")

            if len(stack) < 2:
                tk_die("Not enough arguments for drop", token)

            vprint("Checking assembly ammount")
            assembly_ammount_type, assembly_ammount = stack.pop()

            if assembly_ammount_type != RysType.INT:
                tk_die(
                    f"Assembly expected {type_to_str(RysType.INT)} on the stack as the assembly ammount, but got {type_to_str(assembly_ammount_type)}",
                    token,
                )

            vprint("Checking stack size")
            if len(stack) < assembly_ammount:
                tk_die(
                    f"Assembly: {assembly_ammount} is bigger than the elements on the stack: {len(stack)}",
                    token,
                )

            vprint("Cheking assembly lines")
            for _ in range(assembly_ammount):
                assembly_line_type = stack.pop()[0]

                if assembly_line_type != RysType.STR:
                    tk_die(
                        f"Assembly: expected type {type_to_str(RysType.STR)}, got {type_to_str(assembly_line_type)}",
                        token,
                    )
        elif token.t_type == TokenType.CHARZ:
            vprint("Type checking charz")

            vprint("Checking charz ammount")
            charz_ammount_type, charz_ammount = stack.pop()

            if charz_ammount_type != RysType.INT:
                tk_die(
                    f"Charz expected {type_to_str(RysType.INT)} on the stack as the charz ammount, but got {type_to_str(charz_ammount_type)}",
                    token,
                )

            vprint("Checking stack size")
            if len(stack) < charz_ammount:
                tk_die(
                    f"Charz: {charz_ammount} is bigger than the elements on the stack: {len(stack)}",
                    token,
                )

            vprint(f"Checking {charz_ammount} charcodes")
            for _ in range(charz_ammount):
                charz_charcode_type, charz_charcode = stack.pop()

                if charz_charcode_type != RysType.INT:
                    tk_die(
                        f"Charz: expected type {type_to_str(RysType.INT)}, got {type_to_str(charz_charcode_type)}",
                        token,
                    )

                tmp_stack.append(chr(charz_charcode))

            vprint(f"Pushing {type_to_str(RysType.STR)} onto the typechecking stack")
            stack.append((RysType.STR, "".join(tmp_stack)))
            tmp_stack = []
        elif token.t_type == TokenType.OPERATOR:
            vprint("Found operator")

            if token.t_value == OperatorType.PLUS:
                vprint("Type checking plus operator")

                if len(stack) < 2:
                    tk_die(
                        "Not enough arguments for + on the stack",
                        token,
                    )

                vprint("Type checking plus operator's value 1")

                plus_value1_type, plus_value1 = stack.pop()

                if plus_value1_type != RysType.INT:
                    tk_die(
                        f"+ expected {type_to_str(RysType.INT)} on the stack as the first value, but got {type_to_str(plus_value1_type)}",
                        token,
                    )

                vprint("Type checking plus operator's value 2")

                plus_value2_type, plus_value2 = stack.pop()

                if plus_value2_type != RysType.INT:
                    tk_die(
                        f"+ expected {type_to_str(RysType.INT)} on the stack as the second value, but got {type_to_str(plus_value2_type)}",
                        token,
                    )

                vprint(f"Pushing {type_to_str(RysType.INT)} onto the stack")
                stack.append((RysType.INT, plus_value1 + plus_value2))
            elif token.t_value == OperatorType.MINUS:
                vprint("Type checking minus operator")

                if len(stack) < 2:
                    tk_die(
                        "Not enough arguments for - on the stack",
                        token,
                    )

                vprint("Type checking minus operator's value 1")

                minus_value1_type, minus_value1 = stack.pop()

                if minus_value1_type != RysType.INT:
                    tk_die(
                        f"- expected {type_to_str(RysType.INT)} on the stack as the first value, but got {type_to_str(minus_value1_type)}",
                        token,
                    )

                vprint("Type checking minus operator's value 2")

                minus_value2_type, minus_value2 = stack.pop()

                if minus_value2_type != RysType.INT:
                    tk_die(
                        f"- expected {type_to_str(RysType.INT)} on the stack as the second value, but got {type_to_str(minus_value2_type)}",
                        token,
                    )

                vprint(f"Pushing {type_to_str(RysType.INT)} onto the stack")
                stack.append((RysType.INT, minus_value1 - minus_value2))
            elif token.t_value == OperatorType.MULTIPLY:
                vprint("Type checking multiply operator")

                if len(stack) < 2:
                    tk_die(
                        "Not enough arguments for * on the stack",
                        token,
                    )

                multiply_value1_type, multiply_value1 = stack.pop()

                vprint("Type checking multiply operator's value 1")

                if multiply_value1_type != RysType.INT:
                    tk_die(
                        f"* expected {type_to_str(RysType.INT)} on the stack as the first value, but got {type_to_str(multiply_value1_type)}",
                        token,
                    )

                vprint("Type checking multiply operator's value 2")

                multiply_value2_type, multiply_value2 = stack.pop()

                if multiply_value2_type != RysType.INT:
                    tk_die(
                        f"* expected {type_to_str(RysType.INT)} on the stack as the second value, but got {type_to_str(multiply_value2_type)}",
                        token,
                    )

                vprint(f"Pushing {type_to_str(RysType.INT)} onto the stack")
                stack.append(
                    (RysType.INT, np.multiply(multiply_value1, multiply_value2))
                )
            elif token.t_value == OperatorType.DIVIDE:
                vprint("Type checking divide operator")

                if len(stack) < 2:
                    tk_die(
                        "Not enough arguments for / on the stack",
                        token,
                    )

                vprint("Type checking divide operator's value 1")

                divide_value1_type, divide_value1 = stack.pop()

                if divide_value1_type != RysType.INT:
                    tk_die(
                        f"/ expected {type_to_str(RysType.INT)} on the stack as the first value, but got {type_to_str(divide_value1_type)}",
                        token,
                    )

                vprint("Type checking divide operator's value 2")

                divide_value2_type, divide_value2 = stack.pop()

                if divide_value2_type != RysType.INT:
                    tk_die(
                        f"/ expected {type_to_str(RysType.INT)} on the stack as the second value, but got {type_to_str(divide_value2_type)}",
                        token,
                    )

                if divide_value2 == 0:
                    tk_die(
                        f"Cannot divide {divide_value1!r} by 0",
                        token,
                    )

                vprint(f"Pushing {type_to_str(RysType.INT)} onto the stack")
                stack.append(
                    (RysType.INT, np.floor_divide(divide_value1, divide_value2))
                )
            elif token.t_value == OperatorType.MODULO:
                vprint("Type checking modulo operator")

                if len(stack) < 2:
                    tk_die(
                        "Not enough arguments for % on the stack",
                        token,
                    )

                vprint("Type checking modulo operator's value 1")

                modulo_value1_type, modulo_value1 = stack.pop()

                if modulo_value1_type != RysType.INT:
                    tk_die(
                        f"% expected {type_to_str(RysType.INT)} on the stack as the first value, but got {type_to_str(modulo_value1_type)}",
                        token,
                    )

                vprint("Type checking modulo operator's value 2")

                modulo_value2_type, modulo_value2 = stack.pop()

                if modulo_value2_type != RysType.INT:
                    tk_die(
                        f"% expected {type_to_str(RysType.INT)} on the stack as the second value, but got {type_to_str(modulo_value2_type)}",
                        token,
                    )

                if modulo_value2 == 0:
                    tk_die(
                        f"Cannot divide (in context of modulo) {modulo_value1!r} by 0",
                        token,
                    )

                vprint(f"Pushing {type_to_str(RysType.INT)} onto the stack")
                stack.append((RysType.INT, np.mod(modulo_value1, modulo_value2)))
            elif token.t_value == OperatorType.POWER:
                vprint("Type checking power operator")

                if len(stack) < 2:
                    tk_die(
                        "Not enough arguments for ** on the stack",
                        token,
                    )

                vprint("Type checking power operator's value 1")

                power_value1_type, power_value1 = stack.pop()

                if power_value1_type != RysType.INT:
                    tk_die(
                        f"** expected {type_to_str(RysType.INT)} on the stack as the first value, but got {type_to_str(power_value1_type)}",
                        token,
                    )

                if power_value1 < 0:
                    tk_die(
                        f"** expected positive {type_to_str(RysType.INT)} on the stack as the first value, but got negative {type_to_str(power_value1_type)}",
                        token,
                    )

                vprint("Type checking power operator's value 2")

                power_value2_type, power_value2 = stack.pop()

                if power_value2_type != RysType.INT:
                    tk_die(
                        f"** expected {type_to_str(RysType.INT)} on the stack as the second value, but got {type_to_str(power_value2_type)}",
                        token,
                    )

                if power_value2 < 0:
                    tk_die(
                        f"** expected positive {type_to_str(RysType.INT)} on the stack as the first value, but got negative {type_to_str(power_value2_type)}",
                        token,
                    )

                vprint(f"Pushing {type_to_str(RysType.INT)} onto the stack")
                stack.append(
                    (
                        RysType.INT,
                        np.power(
                            np.ulonglong(power_value1), np.ulonglong(power_value2)
                        ),
                    )
                )
            else:
                tk_die(
                    f"Unknown operator: {token.t_value}",
                    token,
                )
        elif token.t_type == TokenType.STACKSZ:
            vprint("Type checking stacksz")
            vprint(f"Pushing {type_to_str(RysType.INT)} (stack size) onto the stack")
            stack.append((RysType.INT, len(stack)))
        elif token.t_type == TokenType.CPY:
            vprint("Type checking cpy")

            if len(stack) < 2:
                tk_die("Not enough arguments for cpy", token)

            vprint("Type checking cpy ammount")
            cpy_ammount_type, cpy_ammount = stack.pop()

            if cpy_ammount_type != RysType.INT:
                tk_die(
                    f"Cpy expected {type_to_str(RysType.INT)} but got {type_to_str(cpy_ammount_type)}",
                    token,
                )

            vprint("Checking stack length")

            if cpy_ammount > len(stack):
                tk_die(
                    f"Cpy: cannot copy more than {len(stack)} items, the whole length of the stack, cpy asked for {cpy_ammount}",
                    token,
                )

            vprint(f"Copying {cpy_ammount} of elements on the stack")
            for idx in range(cpy_ammount):
                tmp_stack.append(stack[-(idx + 1)])

            stack += tmp_stack[::-1]
            tmp_stack = []
        elif token.t_type == TokenType.NOP:
            vprint("Type checking nop")
            pass
        elif token.t_type == TokenType.CLEAR:
            vprint("Type checking clear")

            if len(stack) == 0:
                tk_die(
                    "Clear: stack is empty, nothing to clear",
                    token,
                )

            vprint("Clearing the stack")
            stack.clear()
        elif token.t_type == TokenType.PROCCESSABLE:
            vprint("Foind a processable token")

            if token.t_value == ProceesableToken.PROC_INCLUDE:
                vprint("Type checking include")

                if len(stack) < 1:
                    tk_die(
                        "Inlude: 'file' argument is missing",
                        token,
                    )

                vprint("Type checking include file")

                include_file_type, include_file = stack.pop()

                if include_file_type != RysType.STR:
                    tk_die(
                        f"Inlude: 'file' argument is supposed to be {type_to_str(RysType.STR)}, not {type_to_str(include_file_type)}",
                        token,
                    )

                vprint(f"Checking if {include_file!r} exists")

                if not os.path.isfile(include_file):
                    tk_die(
                        f"Include: {include_file!r} is not a file/does not exist",
                        token,
                    )

                vprint(f"Gerating AST and typechecking {include_file!r}")
                type_check_ast(rys_to_ast(include_file), False, stack)

        yield token


assert len(ProceesableToken) == 1, "Unhandled processable token types in preprocessing"


def preprocess_rys_ast(
    ast: Generator[Token, None, None],
    ast_tokens: Optional[list[Token]] = None,
    do_msg: bool = True,
) -> Generator[Token, None, None]:
    vprint("Preprocessing an AST")

    if do_msg:
        msg("Preprocessing AST...", "PROCESS")

    tokens: list[Token] = ast_tokens or []

    for t_idx, token in enumerate(ast):
        vprint(
            f"Preprocessing token #{t_idx}: {token.t_type}[{token.t_value}] for file {token.t_pos[-1]!r}"
        )
        tokens.append(token)

        if token.t_type != TokenType.PROCCESSABLE:
            yield token
            continue

        tokens.pop(t_idx)

        if token.t_value == ProceesableToken.PROC_INCLUDE:
            vprint("Preprocessing include")

            vprint("Adding '1 drop' to ast")
            yield Token(TokenType.PUSH_INT, token.t_pos, 1)
            yield Token(TokenType.DROP, token.t_pos, None)

            vprint("Preprocessing, type checking and generating ast for included file")
            for token in preprocess_rys_ast(
                type_check_ast(rys_to_ast(tokens.pop(t_idx - 1).t_value)), tokens
            ):
                yield token
        else:
            tk_die(f"Unknown proccesable token type: {token.t_value}", token)


def main() -> int:
    """Entry/main function"""

    if len(sys.argv) < 2:
        msg("Not sufficient ammount of arguments")
        return usage()

    filename: tuple[str, str] = parse_args()

    if not os.path.exists(filename[0]):
        return msg(f"File {sys.argv[1]!r} does not exist")

    vprint(f"Compiling {filename[0]!r}")

    bin_name: str = filename[1]
    asm_name: str = bin_name + ".asm"
    obj_name: str = bin_name

    asm: Generator[tuple[str, int], None, None]
    ast: Generator[Token, None, None] = preprocess_rys_ast(
        type_check_ast(rys_to_ast(sys.argv[1]))
    )

    asmc: str
    linker: str

    ld_flags: str = ""
    asm_flags: str = ""

    if "format_linux_elf64_x86_64_nasm" in RYS_ARGS:
        vprint(
            "Format detected to be format_linux_elf64_x86_64_nasm, generating assembly"
        )
        asm = generate_x86_64_nasm_assembly_linux(ast)

        if "typing" in RYS_ARGS:
            msg("Only typechecking AST", "TYPING")
            ret: int = EXIT_OK

            try:
                tuple(asm)
            except Exception as err:
                msg(f"Typechecking failed: {err}")
                ret = EXIT_ERR

            return ret

        obj_name += ".o"

        asmc = "nasm"
        linker = "ld"

        vprint("Added default assembly and linker flags")

        asm_flags = f"-w+error -felf64 {asm_name} -o '{obj_name}' "
        ld_flags = f"--require-defined=_start -nostdlib -o '{bin_name}' '{obj_name}' "

        if "debug_flags" in RYS_ARGS:
            vprint("Adding debug linker and assembly flags")

            ld_flags += (
                "-O0 --compress-debug-sections=none --eh-frame-hdr --gc-sections"
            )
            asm_flags += "-g -gdwarf -O0"

        if "release_flags" in RYS_ARGS:
            vprint("Adding release/optimisation linker and assembly flags")

            ld_flags += "-O3 -X -s -S"
            asm_flags += "-O3 -s"
    else:
        msg("No format specified")
        return usage()

    if os.environ.get("RYS_LD_FLAGS"):
        vprint("Found user-set environment LD flags")
        ld_flags = os.environ.get("RYS_LD_FLAGS") or ""

    if os.environ.get("RYS_ASM_FLAGS"):
        vprint("Found user-set environment ASM flags")
        asm_flags = os.environ.get("RYS_ASM_FLAGS") or ""

    ld_flags += f" {os.environ.get('RYS_USER_LD_FLAGS') or ''}"
    asm_flags += f" {os.environ.get('RYS_USER_ASM_FLAGS') or ''}"

    msg(f"Writing assembly to {asm_name}...", "INFO")
    with open(asm_name, "w") as rys_asm:
        for line, _ in asm:
            rys_asm.write((line if "debug_flags" in RYS_ARGS else line.strip()) + "\n")

    msg(f"Compiling {asm_name}...", "INFO")
    vprint(f"{asmc} {asm_flags}")
    if os.system(f"{asmc} {asm_flags}"):
        return msg("Assembler failed")

    vprint(f"{linker} {ld_flags}")
    if os.system(f"{linker} {ld_flags}"):
        return msg("Linker failed")

    if "strip" in RYS_ARGS:
        msg(f"Stripping {bin_name}...", "INFO")
        if os.system(
            f"strip --strip-all \
                    -N __gentoo_check_ldflags__ -R .comment \
                    -R .GCC.command.line --remove-section=.eh_frame \
                    --remove-section=.eh_frame_hdr --remove-section=.gnu.hash \
                    --remove-section=.eh_frame_hdr --remove-section=.eh_frame_ptr \
                    --remove-section=.note.gnu.gold-version \
                    --remove-section=.note.gnu.build-id \
                    --remove-section=.note.ABI-tag --remove-section=.note \
                    --remove-section=.gnu.version --remove-section=.comment \
                    --merge-notes --strip-debug --strip-unneeded -x \
                    {'--verbose' if 'verbose' in RYS_ARGS else ''} -- '{bin_name}'"
        ):
            return msg("Stripper failed")

    if "run" in RYS_ARGS:
        msg(f"Running {bin_name!r}", "INFO")
        vprint(f"./'{bin_name}' {os.environ.get('RYS_OFLAGS') or ''}")
        os.system(f"./'{bin_name}' {os.environ.get('RYS_OFLAGS') or ''}")

    vprint("Finished successfully")
    return 0


if __name__ == "__main__":
    assert main.__annotations__.get("return") is int, "main() should return an integer"
    sys.exit(main())
