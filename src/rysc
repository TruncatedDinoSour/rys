#!/usr/bin/env python3
"""rys"""

import os
import sys
import warnings
from dataclasses import dataclass
from enum import Enum, auto
from typing import Any, Generator, Optional

warnings.filterwarnings("error", category=Warning)

EXIT_OK: int = 0
EXIT_ERR: int = 1
RYS_ARGS: set[str] = set()

__version__ = "0.2"
__author__ = "Ari Archer <ari.web.xyz@gmail.com>"


class TokenType(Enum):
    PUSH_INT = auto()
    PUSH_STR = auto()
    INSTRUCTION = auto()
    DROP = auto()
    ASSEMBLY = auto()


class AsmFeatures(Enum):
    EXIT = auto()
    WRITEFD = auto()
    WRITEFD_INT = auto()


class InstructionType(Enum):
    INSTRUCTION_EXIT = auto()
    INSTRUCTION_WRITEFD = auto()


class RysType(Enum):
    STR = auto()
    INT = auto()


@dataclass
class Token:
    t_type: TokenType
    t_pos: tuple[int, int, str]  # line, column, file
    t_value: Any


ASM_FEATURES: dict[AsmFeatures, list[str]] = {
    AsmFeatures.EXIT: ["_std_rys_exit:", "    mov rax, 60", "    syscall", "    ret"],
    AsmFeatures.WRITEFD: [
        "_std_rys_writefd:",
        "    mov rax, 1",
        "    syscall",
        "    ret",
    ],
    AsmFeatures.WRITEFD_INT: [
        "_std_rys_writefd_int:",
        "   mov r9, -3689348814741910323",
        "   sub rsp, 40",
        "   lea rcx, [rsp+30]",
        ".L2:",
        "   mov rax, rdi",
        "   lea r8, [rsp+32]",
        "   mul r9",
        "   mov rax, rdi",
        "   sub r8, rcx",
        "   shr rdx, 3",
        "   lea rsi, [rdx+rdx*4]",
        "   add rsi, rsi",
        "   sub rax, rsi",
        "   add eax, 48",
        "   mov BYTE [rcx], al",
        "   mov rax, rdi",
        "   mov rdi, rdx",
        "   mov rdx, rcx",
        "   sub rcx, 1",
        "   cmp rax, 9",
        "   ja .L2",
        "   lea rax, [rsp+32]",
        "   sub rdx, rax",
        "   xor eax, eax",
        "   lea rsi, [rsp+32+rdx]",
        "   mov rdx, r8",
        "   mov rax, 1",
        "   syscall",
        "   add rsp, 40",
        "   ret",
    ],
}


def msg(msg: str, header: str = "ERROR") -> int:
    """Print message and return error exit code"""

    if "quiet" not in RYS_ARGS:
        sys.stderr.write(f" ** {header}{': ' if msg[0] != ':' else ''}{msg}\n")

    return EXIT_ERR


def tk_die(message: str, token: Token) -> None:
    sys.exit(
        msg(f":{token.t_pos[2]}:{token.t_pos[0] or 1}:{token.t_pos[1] or 1}: {message}")
    )


def vprint(message: str) -> None:
    if "verbose" not in RYS_ARGS:
        return

    msg(message, "DEBUG")


assert len(RysType) == 2, "Unhandled types in type-to-string"


def type_to_str(r_type: RysType) -> str:
    type_name = "Unknown"

    if r_type == RysType.INT:
        type_name = "integer"
    elif r_type == RysType.STR:
        type_name = "string"

    return type_name


assert len(TokenType) == 5, "Unhandled token types in AST generation"
assert len(InstructionType) == 2, "Unhandled instructions in AST generation"
assert len(RysType) == 2, "Unhandled types in AST generation"


def rys_to_ast(file_path: str) -> Generator[Token, None, None]:
    msg(f"Generating AST for {file_path!r}...", "INFO")

    config: dict[str, Any] = {}
    token_ctx: set[str] = set()
    tmp_stack: list[Any] = []

    def new_token(token_type: TokenType, value: Any) -> Token:
        vprint(f"New token with type {token_type!r} and value of {value!r}")

        return Token(
            token_type,
            (config.get("line") or 1, config.get("column") or 1, file_path),
            value,
        )

    def die(message: str) -> None:
        sys.exit(
            msg(
                f":{file_path}:{config.get('line') or 1}:{config.get('column') or 1}: {message}"
            )
        )

    with open(file_path, "r") as rys_code:
        for lidx, line in enumerate(rys_code, 1):
            if "in.literal" in token_ctx:
                die(
                    f'No closing double quote (") to close {type_to_str(RysType.STR)}',
                )

            config["line"] = lidx

            for cidx, token in enumerate(line.split(), 1):
                config["column"] = cidx

                # String parsing sux
                # TODO: better parsing like wtf does this even fucking
                #       like I mean it works, but I have no idea how to
                #       maintain it, please help :')
                #       btw "\\" does not work

                if "in.literal" in token_ctx:
                    if not token.endswith('"') or token.endswith('\\"'):
                        tmp_stack.append(token)
                        continue
                elif token == '"' and "in.literal" not in token_ctx:
                    token_ctx.add("in.literal")
                    continue

                if (
                    token.startswith('"')
                    and token.endswith('"')
                    and not token.endswith('\\"')
                    and "in.literal" not in token_ctx
                ):
                    yield new_token(TokenType.PUSH_STR, token[1:-1])
                    continue
                elif token.endswith('"') and not token.endswith('\\"'):
                    tmp_stack.append(token.removesuffix('"'))

                    full_str: str = " ".join(tmp_stack)

                    yield new_token(TokenType.PUSH_STR, full_str)

                    tmp_stack = []
                    token_ctx.remove("in.literal")
                    continue
                elif token.startswith('"'):
                    tmp_stack.append(token.removeprefix('"'))
                    token_ctx.add("in.literal")
                    continue

                if token.startswith("--"):
                    # Ignore comments and everything after in the same line
                    break

                if token.isnumeric():
                    try:
                        yield new_token(TokenType.PUSH_INT, int(token))
                    except ValueError:
                        die(
                            f"Failed to convert {token!r} to {type_to_str(RysType.INT)}"
                        )
                else:
                    if token == "exit":
                        yield new_token(
                            TokenType.INSTRUCTION, InstructionType.INSTRUCTION_EXIT
                        )
                    elif token == "writefd":
                        yield new_token(
                            TokenType.INSTRUCTION, InstructionType.INSTRUCTION_WRITEFD
                        )
                    elif token == "drop":
                        yield new_token(TokenType.DROP, None)
                    elif token == "assembly":
                        yield new_token(TokenType.ASSEMBLY, None)
                    else:
                        die(f"Unknown token: {token!r}")

            if "in.literal" in token_ctx:
                die(f'No closing double quote (") to close {type_to_str(RysType.STR)}')


assert (
    len(TokenType) == 5
), "Unhandled token types in nasm x86_64 linux assembly generation"
assert len(InstructionType) == 2, "Unhandled instructions in assembly generation"
assert len(RysType) == 2, "Unhandled types in assembly generation"
assert (
    len(AsmFeatures) == 3
), "Unhandled asm features in generate_x86_64_nasm_assembly_linux()"


def generate_x86_64_nasm_assembly_linux(
    ast: Generator[Token, None, None],
    full: bool = True,
    start_iname: int = 0,
    stack: Optional[list[tuple[Any, RysType]]] = None,
    features: Optional[set[AsmFeatures]] = None,
    do_msg: bool = True,
) -> Generator[tuple[str, int], None, None]:
    """
    API (index 1 of return)
    -----------------------
    0 -- assembly
    1 -- data
    """

    vprint("Generaing assembly for linux x86_64 nasm")

    if do_msg:
        msg("Generating nasm x86_64 linux assembly from AST...", "INFO")

    asm_stack: list[tuple[Any, RysType]] = stack or []
    asm_data: list[Any] = []
    asm_features: set[AsmFeatures] = features or set()
    start_lb: list[str] = []

    if full:
        vprint("Generating nasm x86_64 64-bit initial header")

        yield "BITS 64", 0
        yield "segment .text", 0

    for token in ast:
        iname: str = f"_{start_iname}_{token.t_pos[0]}_{token.t_pos[1]}"

        if token.t_type == TokenType.PUSH_INT:
            if token.t_value > 2**64:
                tk_die(
                    f"{type_to_str(RysType.INT)} {token.t_value!r} does not fit into 64 bits",
                    token,
                )

            asm_stack.append((token.t_value, RysType.INT))
        elif token.t_type == TokenType.PUSH_STR:
            asm_stack.append(
                (
                    token.t_value.encode("raw_unicode_escape", errors="ignore").decode(
                        "unicode_escape", errors="ignore"
                    ),
                    RysType.STR,
                )
            )
        elif token.t_type == TokenType.DROP:
            for _ in range(asm_stack.pop()[0]):
                asm_stack.pop()
        elif token.t_type == TokenType.ASSEMBLY:
            for _ in range(asm_stack.pop()[0]):
                start_lb.append(asm_stack.pop()[0])
        elif token.t_type == TokenType.INSTRUCTION:
            if token.t_value == InstructionType.INSTRUCTION_EXIT:
                start_lb += [f"mov rdi, {asm_stack.pop()[0]}", "call _std_rys_exit"]
                asm_features.add(AsmFeatures.EXIT)
            elif token.t_value == InstructionType.INSTRUCTION_WRITEFD:
                writefd_fd, _, writefd_string, writefd_string_type = (
                    *asm_stack.pop(),
                    *asm_stack.pop(),
                )

                if writefd_string_type == RysType.STR:
                    start_lb += [
                        f"    mov rdi, {writefd_fd}",
                        f"    mov rsi, str{iname}",
                        f"    mov rdx, str_len{iname}",
                        r"    call _std_rys_writefd",
                    ]

                    rys_str: str = ",".join(
                        map(lambda char: str(ord(char)), writefd_string)
                    )

                    asm_data += [
                        f"str{iname}: db {rys_str if rys_str else 0}",
                        f"str_len{iname}: equ $-str{iname}",
                    ]

                    asm_features.add(AsmFeatures.WRITEFD)
                elif writefd_string_type == RysType.INT:
                    start_lb += [
                        f"    mov rdi, {writefd_fd}",
                        f"    mov edi, {writefd_string}",
                        r"    call _std_rys_writefd_int",
                    ]

                    asm_features.add(AsmFeatures.WRITEFD_INT)
                else:
                    tk_die(f"Unknown writefd type: {writefd_string_type}", token)

                asm_stack.append((len(str(writefd_string)), RysType.INT))
        else:
            tk_die(f"Unknown token: {token.t_type}", token)

    if asm_stack:
        msg("Items left on the stack:")

        for val, typ in asm_stack:
            sys.stderr.write(f"  *  {val}{type_to_str(typ):>10s}\n")

        sys.exit(EXIT_ERR)

    vprint("Generating features...")

    for feature in asm_features:
        for line in ASM_FEATURES[feature]:
            yield line, 0

    vprint("Generating _start")

    if not start_lb:
        msg("No actual code found")
        sys.exit(EXIT_ERR)

    if full:
        yield "global _start", 0
        yield "_start:", 0

    for line in start_lb:
        yield line, 0

    vprint("generating .data")

    if full and asm_data:
        yield "segment .data", 1

    for data in asm_data:
        yield data, 1


def usage() -> int:
    help_text = [
        f" Usage: {{ENV}}={{VAL}}... {os.path.basename(sys.argv[0])} <file | -help> -flag(s)",
        "",
        " FLAGS",
        f"    -help                       -- [{'on' if '-help' in sys.argv else 'off'}] print help",
        f"    -debug                      -- [{'on' if '-debug' in sys.argv else 'off'}] use debug build flags",
        f"    -release                    -- [{'on' if '-release' in sys.argv else 'off'}] use release/production build flags",
        f"    -linux-elf64-x86_64-nasm    -- [{'on' if '-linux-elf64-x86_64-nasm' in sys.argv else 'off'}] generate linux elf64 x86_64 binary and assembly",
        f"    -run                        -- [{'on' if '-run' in sys.argv else 'off'}] run binary after compilation",
        f"    --                          -- [{'on' if '--' in sys.argv[1:] else 'off'}] treat next argument as filename",
        f"    -o <filename>               -- [{'on' if '-o' in sys.argv[1:] else 'off'}] output binary",
        f"    -strip                      -- [{'on' if '-strip' in sys.argv else 'off'}] strip binary after compiling",
        f"    -quiet                      -- [{'on' if '-quiet' in sys.argv else 'off'}] run quietly",
        f"    -verbose                    -- [{'on' if '-quiet' in sys.argv else 'off'}] print debug/verbose information",
        f"    -typecheck                  -- [{'on' if '-typecheck' in sys.argv else 'off'}] only typecheck, don't compile",
        f"    -no-typecheck               -- [{'on' if '-no-typecheck' in sys.argv else 'off'}] never typecheck",
        "",
        " ENV",
        "    RYS_LD_FLAGS                -- all linker flags",
        "    RYS_USER_LD_FLAGS           -- extra linker flags to add on top of LD flags",
        "    RYS_ASM_FLAGS               -- all assembly flags",
        "    RYS_USER_ASM_FLAGS          -- extra assembly flags to add on top of ASM flags",
        "    RYS_OFLAGS                  -- flags to pass to output binary if -run is passed",
    ]

    for line in help_text:
        sys.stderr.write(line + "\n")

    return EXIT_ERR


def parse_args() -> tuple[str, str]:
    """Returns the filename and output binary name"""

    if sys.argv[1] == "-help":
        usage()
        sys.exit(EXIT_OK)

    ctx: set = set()
    filename: str = sys.argv[1]
    output: str = ""

    for arg in sys.argv[1:]:
        if "literal" in ctx:
            filename = arg
            ctx.remove("literal")
            continue
        elif "output" in ctx:
            output = arg
            ctx.remove("output")
            continue

        if arg == "-help":
            usage()
            sys.exit()
        elif arg == "-debug":
            RYS_ARGS.add("debug_flags")
        elif arg == "-release":
            RYS_ARGS.add("release_flags")
        elif arg == "-linux-elf64-x86_64-nasm":
            RYS_ARGS.add("format_linux_elf64_x86_64_nasm")
        elif arg == "-run":
            RYS_ARGS.add("run")
        elif arg == "--":
            ctx.add("literal")
        elif arg == "-o":
            ctx.add("output")
        elif arg == "-strip":
            RYS_ARGS.add("strip")
        elif arg == "-quiet":
            RYS_ARGS.add("quiet")
        elif arg == "-verbose":
            RYS_ARGS.add("verbose")
        elif arg == "-typecheck":
            RYS_ARGS.add("typing")
        elif arg == "-no-typecheck":
            RYS_ARGS.add("no-typing")
        elif os.path.exists(arg):
            continue
        else:
            sys.exit(msg(f"Unknown argument: {arg!r}"))

    return (filename, output or os.path.splitext(os.path.basename(filename))[0])


assert len(TokenType) == 5, "Unhandled token types in type checking"
assert len(InstructionType) == 2, "Unhandled instructions in type checking"
assert len(RysType) == 2, "Unhandled types in type checking"


def type_check_ast(
    ast: Generator[Token, None, None], do_msg: bool = True
) -> Generator[Token, None, None]:
    if "no-typing" in RYS_ARGS:
        vprint("Not type-checking AST")

        for token in ast:
            yield token

        return

    vprint("Type checking AST")

    if do_msg:
        msg("Type checking program...", "INFO")

    stack: list[tuple[RysType, int]] = []

    for token in ast:
        if token.t_type == TokenType.PUSH_INT:
            stack.append((RysType.INT, token.t_value))
            vprint("Type checking stack: push INT")
        elif token.t_type == TokenType.PUSH_STR:
            stack.append((RysType.STR, token.t_value))
            vprint("Type checking stack: push STR")
        elif token.t_type == TokenType.INSTRUCTION:
            vprint("Found instruction")

            if token.t_value == InstructionType.INSTRUCTION_EXIT:
                vprint("Type checking exit instruction")

                if len(stack) < 1:
                    tk_die("Exit code not supplied", token)

                exit_code_type, _ = stack.pop()
                if exit_code_type != RysType.INT:
                    tk_die(
                        f"Exit expected {type_to_str(RysType.INT)} on the stack as exit code, but got {type_to_str(exit_code_type)}",
                        token,
                    )
            elif token.t_value == InstructionType.INSTRUCTION_WRITEFD:
                vprint("Type checking writefd instruction")

                if len(stack) < 2:
                    tk_die("Not enough arguments for writefd", token)

                fd_type, _ = stack.pop()

                if fd_type != RysType.INT:
                    tk_die(
                        f"WriteFD expected a {type_to_str(RysType.INT)} {type_to_str(RysType.INT)} the stack as the file descriptor, but got {type_to_str(fd_type)}",
                        token,
                    )

                string_type, string = stack.pop()

                if string_type not in (RysType.STR, RysType.INT):
                    tk_die(
                        f"writefd expected one of {', '.join(type_to_str(typ) for typ in (RysType.INT, RysType.STR))} on the stack as the content, but got {type_to_str(string_type)}",
                        token,
                    )

                stack.append((RysType.INT, len(str(string))))
        elif token.t_type == TokenType.DROP:
            vprint("Type checking drop")

            if len(stack) < 2:
                tk_die("Not enough arguments for drop", token)

            drop_ammount_type, drop_ammount = stack.pop()

            if drop_ammount_type != RysType.INT:
                tk_die(
                    f"Drop expected a {type_to_str(RysType.INT)} on the stack as the ammount of items to drop, but got {type_to_str(drop_ammount_type)}",
                    token,
                )

            if len(stack) < drop_ammount:
                tk_die(
                    f"Drop: {drop_ammount} is bigger than the elements on the stack: {len(stack)}",
                    token,
                )

            for _ in range(drop_ammount):
                stack.pop()
        elif token.t_type == TokenType.ASSEMBLY:
            if len(stack) < 2:
                tk_die("Not enough arguments for drop", token)

            assembly_ammount_type, assembly_ammount = stack.pop()

            if assembly_ammount_type != RysType.INT:
                tk_die(
                    f"Assembly expected a {type_to_str(RysType.INT)} on the stack as the assembly ammount, but got {type_to_str(assembly_ammount_type)}",
                    token,
                )

            if len(stack) < assembly_ammount:
                tk_die(
                    f"Assembly: {assembly_ammount} is bigger than the elements on the stack: {len(stack)}",
                    token,
                )

            for _ in range(assembly_ammount):
                assembly_line_type, _ = stack.pop()

                if assembly_line_type != RysType.STR:
                    tk_die(
                        f"Assembly: expected type {type_to_str(RysType.STR)}, got {type_to_str(assembly_line_type)}",
                        token,
                    )

        yield token


def main() -> int:
    """Entry/main function"""

    if len(sys.argv) < 2:
        msg("Not sufficient ammount of arguments")
        return usage()

    filename: tuple[str, str] = parse_args()

    if not os.path.exists(filename[0]):
        return msg(f"File {sys.argv[1]!r} does not exist")

    vprint(f"Compiling {filename[0]!r}")

    bin_name: str = filename[1]
    asm_name: str = bin_name + ".asm"
    obj_name: str = bin_name

    asm: Generator[tuple[str, int], None, None]
    ast: Generator[Token, None, None] = type_check_ast(rys_to_ast(sys.argv[1]))

    asmc: str
    linker: str

    ld_flags: str = ""
    asm_flags: str = ""

    if "format_linux_elf64_x86_64_nasm" in RYS_ARGS:
        asm = generate_x86_64_nasm_assembly_linux(ast)

        if "typing" in RYS_ARGS:
            msg("Only typechecking AST", "TYPING")
            ret: int = EXIT_OK

            try:
                tuple(asm)
            except Exception as err:
                msg(f"Typechecking failed: {err}")
                ret = EXIT_ERR

            return ret

        obj_name += ".o"

        asmc = "nasm"
        linker = "ld"

        asm_flags = f"-w+error -felf64 {asm_name} -o '{obj_name}' "
        ld_flags = f"--require-defined=_start -nostdlib -o '{bin_name}' '{obj_name}' "

        if "debug_flags" in RYS_ARGS:
            ld_flags += (
                "-O0 --compress-debug-sections=none --eh-frame-hdr --gc-sections"
            )
            asm_flags += "-g -gdwarf -O0"

        if "release_flags" in RYS_ARGS:
            ld_flags += "-O3 -X -s -S"
            asm_flags += "-O3 -s"
    else:
        msg("No format specified")
        return usage()

    if os.environ.get("RYS_LD_FLAGS"):
        ld_flags = os.environ.get("RYS_LD_FLAGS") or ""

    if os.environ.get("RYS_ASM_FLAGS"):
        asm_flags = os.environ.get("RYS_ASM_FLAGS") or ""

    ld_flags += f" {os.environ.get('RYS_USER_LD_FLAGS') or ''}"
    asm_flags += f" {os.environ.get('RYS_USER_ASM_FLAGS') or ''}"

    msg(f"Writing assembly to {asm_name}...", "INFO")
    with open(asm_name, "w") as rys_asm:
        for line, _ in asm:
            rys_asm.write((line if "debug_flags" in RYS_ARGS else line.strip()) + "\n")

    msg(f"Compiling {asm_name}...", "INFO")
    vprint(f"{asmc} {asm_flags}")
    if os.system(f"{asmc} {asm_flags}"):
        return msg("Assembler failed")

    vprint(f"{linker} {ld_flags}")
    if os.system(f"{linker} {ld_flags}"):
        return msg("Linker failed")

    if "strip" in RYS_ARGS:
        msg(f"Stripping {bin_name}...", "INFO")
        if os.system(
            f"strip --strip-all \
                    -N __gentoo_check_ldflags__ -R .comment \
                    -R .GCC.command.line --remove-section=.eh_frame \
                    --remove-section=.eh_frame_hdr --remove-section=.gnu.hash \
                    --remove-section=.eh_frame_hdr --remove-section=.eh_frame_ptr \
                    --remove-section=.note.gnu.gold-version \
                    --remove-section=.note.gnu.build-id \
                    --remove-section=.note.ABI-tag --remove-section=.note \
                    --remove-section=.gnu.version --remove-section=.comment \
                    --merge-notes --strip-debug --strip-unneeded -x \
                    {'--verbose' if 'verbose' in RYS_ARGS else ''} -- '{bin_name}'"
        ):
            return msg("Stripper failed")

    if "run" in RYS_ARGS:
        msg(f"Running {bin_name!r}", "INFO")
        vprint(f"./'{bin_name}' {os.environ.get('RYS_OFLAGS') or ''}")
        os.system(f"./'{bin_name}' {os.environ.get('RYS_OFLAGS') or ''}")

    return 0


if __name__ == "__main__":
    assert main.__annotations__.get("return") is int, "main() should return an integer"
    sys.exit(main())
