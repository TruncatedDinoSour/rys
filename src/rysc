#!/usr/bin/env python3
"""rys"""

import os
import sys
import warnings
from dataclasses import dataclass
from enum import Enum, auto
from typing import Any, Generator, Optional

warnings.filterwarnings("error", category=Warning)

EXIT_OK: int = 0
EXIT_ERR: int = 1
RYS_ARGS: set[str] = set()

__version__ = "0.1"
__author__ = "Ari Archer <truncateddinosour@gmail.com>"


class TokenType(Enum):
    PUSH_INT = auto()
    PUSH_STR = auto()
    DROP = auto()
    INSTRUCTION = auto()


class InstructionType(Enum):
    INSTRUCTION_EXIT = auto()
    INSTRUCTION_WRITEFD = auto()


class RysType(Enum):
    STR = auto()
    INT = auto()


@dataclass
class Token:
    t_type: TokenType
    t_pos: tuple[int, int, str]  # line, column, file
    t_value: Any


def msg(msg: str, header: str = "ERROR") -> int:
    """Print message and return error exit code"""

    if "quiet" not in RYS_ARGS:
        sys.stderr.write(f" ** {header}{': ' if msg[0] != ':' else ''}{msg}\n")

    return EXIT_ERR


def tk_die(message: str, token: Token) -> None:
    sys.exit(
        msg(f":{token.t_pos[2]}:{token.t_pos[0] or 1}:{token.t_pos[1] or 1}: {message}")
    )


def vprint(message: str) -> None:
    if "verbose" not in RYS_ARGS:
        return

    msg(message, "DEBUG")


assert len(RysType) == 2, "Unhandled types in type-to-string"


def type_to_str(r_type: RysType) -> str:
    type_name = "Unknown"

    if r_type == RysType.INT:
        type_name = "integer"
    elif r_type == RysType.STR:
        type_name = "string"

    return type_name


assert len(TokenType) == 4, "Unhandled token types in AST generation"
assert len(InstructionType) == 2, "Unhandled instructions in AST generation"
assert len(RysType) == 2, "Unhandled types in AST generation"


def rys_to_ast(file_path: str) -> Generator[Token, None, None]:
    msg(f"Generating AST for {file_path!r}...", "INFO")

    config: dict[str, Any] = {}
    token_ctx: set[str] = set()
    tmp_stack: list[Any] = []

    def new_token(token_type: TokenType, value: Any) -> Token:
        vprint(f"New token with type {token_type!r} and value of {value!r}")

        return Token(
            token_type,
            (config.get("line") or 1, config.get("column") or 1, file_path),
            value,
        )

    def die(message: str) -> None:
        sys.exit(
            msg(
                f":{file_path}:{config.get('line') or 1}:{config.get('column') or 1}: {message}"
            )
        )

    with open(file_path, "r") as rys_code:
        for lidx, line in enumerate(rys_code, 1):
            if "in.literal" in token_ctx:
                die(
                    f'No closing double quote (") to close {type_to_str(RysType.STR)}',
                )

            config["line"] = lidx

            for cidx, token in enumerate(line.split(), 1):
                config["column"] = cidx

                # String parsing sux
                if "in.literal" in token_ctx:
                    if not token.endswith('"') or token.endswith('\\"'):
                        tmp_stack.append(token)
                        continue
                elif token == '"' and "in.literal" not in token_ctx:
                    token_ctx.add("in.literal")
                    continue

                if (
                    token.startswith('"')
                    and token.endswith('"')
                    and not token.endswith('\\"')
                    and "in.literal" not in token_ctx
                ):
                    yield new_token(TokenType.PUSH_STR, token[1:-1])
                    continue
                elif token.endswith('"') and not token.endswith('\\"'):
                    tmp_stack.append(token.removesuffix('"'))

                    full_str: str = " ".join(tmp_stack)

                    yield new_token(TokenType.PUSH_STR, full_str)

                    tmp_stack = []
                    token_ctx.remove("in.literal")
                    continue
                elif token.startswith('"'):
                    tmp_stack.append(token.removeprefix('"'))
                    token_ctx.add("in.literal")
                    continue

                if token.startswith("--"):
                    # Ignore comments and everything after in the same line
                    break

                if token.isnumeric():
                    try:
                        yield new_token(TokenType.PUSH_INT, int(token))
                    except ValueError:
                        die(
                            f"Failed to convert {token!r} to {type_to_str(RysType.INT)}"
                        )
                else:
                    if token == "exit":
                        yield new_token(
                            TokenType.INSTRUCTION, InstructionType.INSTRUCTION_EXIT
                        )
                    elif token == "writefd":
                        yield new_token(
                            TokenType.INSTRUCTION, InstructionType.INSTRUCTION_WRITEFD
                        )
                    elif token == "drop":
                        yield new_token(TokenType.DROP, None)
                    else:
                        die(f"Unknown token: {token!r}")

            if "in.literal" in token_ctx:
                die('No closing double quote (") to close {type_to_str(RysType.STR)}')


assert (
    len(TokenType) == 4
), "Unhandled token types in nasm x86_64 linux assembly generation"
assert len(InstructionType) == 2, "Unhandled instructions in assembly generation"
assert len(RysType) == 2, "Unhandled types in assembly generation"


def generate_x86_64_nasm_assembly_linux(
    ast: Generator[Token, None, None],
    full: bool = True,
    start_iname: int = 0,
    stack: Optional[list[tuple[Any, RysType]]] = None,
    features: Optional[set[str]] = None,
    do_msg: bool = True,
) -> Generator[tuple[str, int], None, None]:
    """
    API (index 1 of return)
    -----------------------
    0 -- assembly
    1 -- data
    """

    vprint("Generaing assembly for linux x86_64 nasm")

    if do_msg:
        msg("Generating nasm x86_64 linux assembly from AST...", "INFO")

    data_section: list[str] = []

    tmp_stack: list[tuple[Any, RysType]] = stack or []

    if full:
        vprint("Generating nasm x86_64 64-bit initial header")

        yield "BITS 64", 0
        yield "segment .text", 0
        yield "global _start", 0
        yield "_start:", 0
        yield "    lea rax, [rel rys_stack_end]", 0

    for token in ast:
        # Ignore the raw (r"...") strings, I cannot stand unalignments
        # ---------------------------------------------------------------------------
        # Conversions with int(), str(), .. are there because some stuff might
        #             be marked as a number where it's a string or something
        # ---------------------------------------------------------------------------
        # We need to simulate the stack at least a bit for some instructions

        iname: str = (
            f"{token.t_pos[0]}_{token.t_pos[1]}__{start_iname}_{token.t_type.value}"
        )
        start_iname += 1

        if token.t_type == TokenType.PUSH_INT:
            if token.t_value > 2 ** 64:
                tk_die(
                    f"Oveflow error: {type_to_str(RysType.INT)} {token.t_value} does not fit into 64 bits",
                    token,
                )

            vprint(f"Push {type_to_str(RysType.INT)} {token.t_value}")

            yield f"int_{iname}:", 0
            yield f"    mov rax, {token.t_value}", 0
            yield r"    push rax", 0

            tmp_stack.append((int(token.t_value), RysType.INT))
        elif token.t_type == TokenType.PUSH_STR:
            data_section.append(
                f"addr_str_{iname}: db {','.join((str(ord(char)) for char in token.t_value.encode('raw-unicode-escape', errors='replace').decode('unicode-escape', errors='replace')))}"
            )

            vprint(f"Push {type_to_str(RysType.STR)} {token.t_value}")

            yield f"str_{iname}:", 0
            yield f"    mov rax, addr_str_{iname}", 0
            yield r"    push rax", 0

            tmp_stack.append((str(token.t_value), RysType.STR))
        elif token.t_type == TokenType.INSTRUCTION:
            if token.t_value == InstructionType.INSTRUCTION_EXIT:
                if len(tmp_stack) < 1:
                    tk_die("Exit code not supplied", token)

                vprint(f"Syscall 60 (exit), rdi = {tmp_stack.pop()[0]}")

                yield f"inst_{iname}:", 0
                yield "    mov rax, 60", 0
                yield "    pop rdi", 0
                yield "    syscall", 0
            elif InstructionType.INSTRUCTION_WRITEFD:
                if len(tmp_stack) < 2:
                    tk_die("Not enough arguments for writefd", token)

                fd = tmp_stack.pop()

                if fd[1] != RysType.INT:
                    tk_die(
                        f"File descriptor is not {type_to_str(RysType.INT)}: {fd[0]}",
                        token,
                    )
                elif fd[0] > 2048:
                    tk_die(
                        f"Linux cannot open more than 2048 file descriptors, so {fd[0]} will always fail",
                        token,
                    )
                    # (1024) https://docs.oracle.com/cd/E19623-01/820-6168/file-descriptor-requirements.html
                    # (2048) https://stackoverflow.com/a/28212496/17411100
                    # NOTE: should I remove this check?..

                fd_data = tmp_stack.pop()

                if fd_data[1] != RysType.STR:
                    tk_die(f"{fd_data[1]!r} is not a valid type for writefd", token)

                fd_data_len = (
                    len(fd_data[0]) - 1
                )  # Without `- 1` it seems to be causing a leak(?)

                vprint("Syscall 1 -- write")

                yield f"writefd_{iname}:", 0
                yield r"    mov rax, 1", 0
                yield r"    pop rdi", 0
                yield r"    pop rsi", 0
                yield f"    mov rdx, {fd_data_len}", 0
                yield r"    syscall", 0

                tmp_stack.append((fd_data_len, RysType.INT))
                # https://man7.org/linux/man-pages/man2/write.2.html
        elif token.t_type == TokenType.DROP:
            if len(tmp_stack) < 2:
                tk_die("Not enough arguments for drop", token)

            drop_ammount = tmp_stack.pop()

            if drop_ammount[1] != RysType.INT:
                tk_die(
                    f"{drop_ammount[0]!r} is not a valid ammount of items to drop",
                    token,
                )
            elif drop_ammount[0] > len(tmp_stack):
                tk_die("Cannot drop more elements than the stack itself", token)

            yield f"drop_{iname}:", 0
            for _ in range(drop_ammount[0]):
                yield r"    pop rax", 0
                vprint(f"Drop {tmp_stack.pop()[0]}")

    if tmp_stack:
        msg(f"{len(tmp_stack)} items left on the stack:")

        for item in tmp_stack:
            msg(f"{item[0]!r:50s}\t({type_to_str(item[1])})", "STACK")

        msg(f"did you miss: {len(tmp_stack)} drop ?", "TIP")
        sys.exit(EXIT_ERR)

    if data_section and full:
        vprint("Creating data segment")
        yield "segment .data", 0

    for data in data_section:
        vprint(f"Data: {data!r}")
        yield data, 1

    if full:
        vprint("Creating BSS")

        yield "segment .bss", 0
        yield "rys_stack_end:", 0


def usage() -> int:
    help_text = [
        f" Usage: {{ENV}}={{VAL}}... {sys.argv[0]} <file | -help> -flag(s)",
        "",
        " FLAGS",
        f"    -help                       -- [{'on' if '-help' in sys.argv else 'off'}] print help",
        f"    -debug                      -- [{'on' if '-debug' in sys.argv else 'off'}] use debug build flags",
        f"    -release                    -- [{'on' if '-release' in sys.argv else 'off'}] use release/production build flags",
        f"    -linux-elf64-x86_64-nasm    -- [{'on' if '-linux-elf64-x86_64-nasm' in sys.argv else 'off'}] generate linux elf64 x86_64 binary and assembly",
        f"    -run                        -- [{'on' if '-run' in sys.argv else 'off'}] run binary after compilation",
        f"    --                          -- [{'on' if '--' in sys.argv[1:] else 'off'}] treat next argument as filename",
        f"    -o <filename>               -- [{'on' if '-o' in sys.argv[1:] else 'off'}] output binary",
        f"    -strip                      -- [{'on' if '-strip' in sys.argv else 'off'}] strip binary after compiling",
        f"    -quiet                      -- [{'on' if '-quiet' in sys.argv else 'off'}] run quietly",
        f"    -verbose                    -- [{'on' if '-quiet' in sys.argv else 'off'}] add verbose flags to compilers",
        "",
        " ENV",
        "    RYS_LD_FLAGS                -- all linker flags",
        "    RYS_USER_LD_FLAGS           -- extra linker flags to add on top of LD flags",
        "    RYS_ASM_FLAGS               -- all assembly flags",
        "    RYS_USER_ASM_FLAGS          -- extra assembly flags to add on top of ASM flags",
        "    RYS_OFLAGS                  -- flags to pass to output binary if -run is passed",
    ]

    for line in help_text:
        sys.stderr.write(line + "\n")

    return EXIT_ERR


def parse_args() -> tuple[str, str]:
    """Returns the filename and output binary name"""

    if sys.argv[1] == "-help":
        usage()
        sys.exit(EXIT_OK)

    ctx: set = set()
    filename: str = sys.argv[1]
    output: str = ""

    for arg in sys.argv[1:]:
        if "literal" in ctx:
            filename = arg
            ctx.remove("literal")
            continue
        elif "output" in ctx:
            output = arg
            ctx.remove("output")
            continue

        if arg == "-help":
            usage()
            sys.exit()
        elif arg == "-debug":
            RYS_ARGS.add("debug_flags")
        elif arg == "-release":
            RYS_ARGS.add("release_flags")
        elif arg == "-linux-elf64-x86_64-nasm":
            RYS_ARGS.add("format_linux_elf64_x86_64_nasm")
        elif arg == "-run":
            RYS_ARGS.add("run")
        elif arg == "--":
            ctx.add("literal")
        elif arg == "-o":
            ctx.add("output")
        elif arg == "-strip":
            RYS_ARGS.add("strip")
        elif arg == "-quiet":
            RYS_ARGS.add("quiet")
        elif arg == "-verbose":
            RYS_ARGS.add("verbose")
        elif os.path.exists(arg):
            continue
        else:
            sys.exit(msg(f"Unknown argument: {arg!r}"))

    return (filename, output or os.path.splitext(os.path.basename(filename))[0])


assert len(TokenType) == 4, "Unhandled token types in type checking"
assert len(InstructionType) == 2, "Unhandled instructions in type checking"
assert len(RysType) == 2, "Unhandled types in type checking"


def type_check_ast(
    ast: Generator[Token, None, None], do_msg: bool = True
) -> Generator[Token, None, None]:
    vprint("Type checking AST")

    if do_msg:
        msg("Type checking program...", "INFO")

    stack: list[RysType] = []

    for token in ast:
        if token.t_type == TokenType.PUSH_INT:
            stack.append(RysType.INT)
            vprint("Type checking stack: push INT")
        elif token.t_type == TokenType.PUSH_STR:
            stack.append(RysType.STR)
            vprint("Type checking stack: push STR")
        elif token.t_type == TokenType.INSTRUCTION:
            vprint("Found instruction")

            if token.t_value == InstructionType.INSTRUCTION_EXIT:
                vprint("Type checking exit instruction")

                if len(stack) < 1:
                    tk_die("Exit code not supplied", token)

                exit_code = stack.pop()
                if exit_code != RysType.INT:
                    tk_die(
                        f"Exit expected {type_to_str(RysType.INT)} on the stack as exit code, but got {type_to_str(exit_code)}",
                        token,
                    )
            elif token.t_value == InstructionType.INSTRUCTION_WRITEFD:
                vprint("Type checking writefd instruction")

                if len(stack) < 2:
                    tk_die("Not enough arguments for writefd", token)

                fd = stack.pop()

                if fd != RysType.INT:
                    tk_die(
                        f"WriteFD expected a {type_to_str(RysType.INT)} {type_to_str(RysType.INT)} the stack as the file descriptor, but got {type_to_str(fd)}",
                        token,
                    )

                string = stack.pop()

                if string != RysType.STR:
                    tk_die(
                        f"writefd expected a string on the stack as the content, but got {type_to_str(string)}",
                        token,
                    )

                stack.append(string)
        elif token.t_type == TokenType.DROP:
            vprint("Type checking drop")

            if len(stack) < 2:
                tk_die("Not enough arguments for drop", token)

            drop_ammount = stack.pop()

            if drop_ammount != RysType.INT:
                tk_die(
                    f"Drop expected a {type_to_str(RysType.INT)} on the stack as the ammount of items to drop, but got {type_to_str(drop_ammount)}",
                    token,
                )

        yield token


def main() -> int:
    """Entry/main function"""
    if len(sys.argv) < 2:
        msg("Not sufficient ammount of arguments")
        return usage()

    filename: tuple[str, str] = parse_args()

    if not os.path.exists(filename[0]):
        return msg(f"File {sys.argv[1]!r} does not exist")

    bin_name: str = filename[1]
    asm_name: str = bin_name + ".asm"
    obj_name: str = bin_name

    asm: Generator[tuple[str, int], None, None]
    ast: Generator[Token, None, None] = type_check_ast(rys_to_ast(sys.argv[1]))

    asmc: str
    linker: str

    ld_flags: str = ""
    asm_flags: str = ""

    if "format_linux_elf64_x86_64_nasm" in RYS_ARGS:
        asm = generate_x86_64_nasm_assembly_linux(ast)

        obj_name += ".o"

        asmc = "nasm"
        linker = "ld"

        asm_flags = f"-w+error -felf64 {asm_name} -o '{obj_name}' "
        ld_flags = f"--require-defined=_start -nostdlib -o '{bin_name}' '{obj_name}' "

        if "debug_flags" in RYS_ARGS:
            ld_flags += (
                "-O0 --compress-debug-sections=none --eh-frame-hdr --gc-sections"
            )
            asm_flags += "-g -gdwarf -O0"

        if "release_flags" in RYS_ARGS:
            ld_flags += "-O3 -X -s -S"
            asm_flags += "-O3 -s"
    else:
        msg("No format specified")
        return usage()

    if os.environ.get("RYS_LD_FLAGS"):
        ld_flags = os.environ.get("RYS_LD_FLAGS") or ""

    if os.environ.get("RYS_ASM_FLAGS"):
        asm_flags = os.environ.get("RYS_ASM_FLAGS") or ""

    ld_flags += f" {os.environ.get('RYS_USER_LD_FLAGS') or ''}"
    asm_flags += f" {os.environ.get('RYS_USER_ASM_FLAGS') or ''}"

    msg(f"Writing assembly to {asm_name}...", "INFO")
    with open(asm_name, "w") as rys_asm:
        for line, _ in asm:
            rys_asm.write(line + "\n")

    msg(f"Compiling {asm_name}...", "INFO")
    vprint(f"{asmc} {asm_flags}")
    if os.system(f"{asmc} {asm_flags}"):
        return msg("Assembler failed")

    vprint(f"{linker} {ld_flags}")
    if os.system(f"{linker} {ld_flags}"):
        return msg("Linker failed")

    if "strip" in RYS_ARGS:
        msg(f"Stripping {bin_name}...", "INFO")
        if os.system(
            f"strip --strip-all \
                    -N __gentoo_check_ldflags__ -R .comment \
                    -R .GCC.command.line --remove-section=.eh_frame \
                    --remove-section=.eh_frame_hdr --remove-section=.gnu.hash \
                    --remove-section=.eh_frame_hdr --remove-section=.eh_frame_ptr \
                    --remove-section=.note.gnu.gold-version \
                    --remove-section=.note.gnu.build-id \
                    --remove-section=.note.ABI-tag --remove-section=.note \
                    --remove-section=.gnu.version --remove-section=.comment \
                    --merge-notes --strip-debug --strip-unneeded -x \
                    {'--verbose' if 'verbose' in RYS_ARGS else ''} -- '{bin_name}'"
        ):
            return msg("Stripper failed")

    if "run" in RYS_ARGS:
        msg(f"Running {bin_name!r}", "INFO")
        vprint(f"./'{bin_name}' {os.environ.get('RYS_OFLAGS') or ''}")
        os.system(f"./'{bin_name}' {os.environ.get('RYS_OFLAGS') or ''}")

    return 0


if __name__ == "__main__":
    assert main.__annotations__.get("return") is int, "main() should return an integer"
    sys.exit(main())
